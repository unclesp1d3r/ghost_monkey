---
globs: *.nim,*.nims
description: Nim development standards and patterns for Ghost_Monkey
---

# Nim Development Standards

## Code Style

- Use explicit type annotations for clarity
- Prefer `let` over `var` when possible
- Use descriptive variable names (`client`, `server`, `command`, `result`)
- Follow Nim naming conventions (camelCase for variables)

## Dependencies

- Always use `strenc` module for string operations
- Import order: standard library first, then third-party packages
- Required imports: `net`, `osproc`, `os`, `strutils`, `strenc`

## Socket Programming

- Always set `OptReuseAddr` for server sockets
- Use proper error handling with try/except blocks
- Close sockets explicitly in finally blocks
- Use `\r\L` for line endings in network protocols

## Security Considerations

- Never hardcode external IP addresses (accept user input)
- Validate all input before processing
- Use non-privileged execution contexts
- Implement proper connection cleanup

### Authentication and Authorization (CRITICAL)

**⚠️ WARNING: The documented unauthenticated protocol MUST NOT be used in production without proper authentication controls.**

#### Transport Security

```nim
# Enable TLS for all communications
import net, ssl

# Configure TLS context with strong cipher suites
let sslContext = newContext(verifyMode = CVerifyPeer)
sslContext.loadCertificates("server.crt", "server.key")
```

#### Authentication Requirements

- **Token-based authentication**: Implement JWT or similar token validation
- **Mutual TLS (mTLS)**: Preferred for client-server authentication
- **Request authorization**: Validate every command before execution
- **Role-based access control (RBAC)**: Implement least-privilege access

#### Secure Configuration Examples

```nim
# Token-based authentication example
import jwt, times

type AuthConfig = object
  secretKey: string
  tokenExpiry: Duration
  allowedRoles: seq[string]

proc validateToken(token: string, config: AuthConfig): bool =
  try:
    let claims = verify(token, config.secretKey)
    let expiry = claims["exp"].getInt
    let role = claims["role"].getStr
    return getTime().toUnix < expiry and role in config.allowedRoles
  except:
    return false

# mTLS configuration example
proc setupSecureServer(port: int): Socket =
  let server = newSocket()
  server.setSockOpt(OptReuseAddr, true)
  server.bindAddr(Port(port))
  server.listen()
  return server
```

#### Credential Management

- **Automatic rotation**: Implement credential rotation (max 24h for tokens)
- **Expiration handling**: Set short-lived credentials with automatic expiry
- **Secure storage**: Use secure key management systems
- **No hardcoded secrets**: Never embed credentials in source code

#### Security Controls

```nim
# Rate limiting and session management
type SecurityConfig = object
  maxRequestsPerMinute: int
  sessionTimeout: Duration
  auditLogPath: string

proc enforceRateLimit(client: string, config: SecurityConfig): bool =
  # Implement rate limiting logic
  # Log all authentication attempts
  # Return true if within limits
```

#### Production Security Checklist

- [ ] TLS encryption enforced for all connections
- [ ] Authentication required before command execution
- [ ] RBAC implemented with least-privilege access
- [ ] Credentials properly rotated and expired
- [ ] Rate limiting and abuse detection enabled
- [ ] Audit logging for all access attempts
- [ ] Session management with timeouts
- [ ] No plaintext protocol communications
- [ ] Security controls tested and verified

**CRITICAL**: Never deploy the unauthenticated protocol to production environments. All production deployments MUST implement the authentication controls described above.

## Build Commands

```bash
# Debug build
nim c client.nim
nim c implant.nim

# Release build
nim c -d:release client.nim
nim c -d:release implant.nim

# Static analysis
nim check client.nim
nim check implant.nim
```
