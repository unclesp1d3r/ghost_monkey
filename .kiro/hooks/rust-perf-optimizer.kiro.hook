{
  "enabled": true,
  "name": "Rust Performance Optimizer",
  "description": "Analyzes changed Rust and protobuf source files for runtime performance characteristics while preserving correctness, public APIs, and security constraints. Applies only clearly safe micro-optimizations across 10 focus categories including algorithmic complexity, allocation behavior, async patterns, I/O efficiency, data structures, caching, error handling, logging costs, memory footprint, and instrumentation opportunities.",
  "version": "1",
  "when": {
    "type": "fileEdited",
    "patterns": [
      "**/*.rs",
      "**/*.proto",
      "**/Cargo.toml"
    ]
  },
  "then": {
    "type": "askAgent",
    "prompt": "# Rust Performance Optimization Hook\n\nAnalyze the changed Rust/protobuf files for performance improvements. Apply only safe, mechanical optimizations that preserve behavior.\n\n## STEP 1: Identify Changed Files\nFirst, use `grepSearch` or `readFile` to examine the modified files. Focus only on the diff scope.\n\n## STEP 2: Performance Analysis\nFor each changed file, analyze these categories:\n\n**Algorithmic Complexity**: Look for O(nÂ²) loops, repeated scans, unnecessary clones\n**Memory Allocation**: Check Vec growth patterns, temporary allocations, string churn\n**Async Patterns**: Find blocking calls in async, unnecessary awaits, poor join patterns\n**I/O Efficiency**: Spot sync I/O in async context, redundant reads/writes\n**Data Structures**: Identify better fits (HashMap vs Vec scan, SmallVec opportunities)\n**Caching**: Find repeated computations, serialization, formatting\n**Error Handling**: Check expensive string formatting on hot paths\n**Logging**: Look for unguarded expensive formatting\n**Memory Usage**: Find unbounded growth, large temporary clones\n**Instrumentation**: Identify missing tracing on hot paths\n\n## STEP 3: Apply Safe Optimizations\nOnly make these types of changes:\n- Remove unnecessary `.clone()` calls\n- Add `Vec::with_capacity()` when size is known\n- Replace `format!` in loops with `push_str`\n- Hoist constant computations out of loops\n- Add early returns for empty inputs\n- Use iterators instead of collecting to Vec\n- Replace blocking I/O with async equivalents\n- Add tracing guards for expensive logging\n\n## STEP 4: Validation\nAfter each change:\n1. Run `executeBash` with `just lint`\n2. Run `executeBash` with `just test`\n3. If either fails, revert the change\n\n## STEP 5: Report Results\nProvide a summary with:\n- Files analyzed\n- Optimizations applied\n- Optimizations deferred (with reasons)\n- Performance impact estimates\n- Next steps recommendations\n\n## CONSTRAINTS\n- NEVER change public APIs or function signatures\n- NEVER introduce `unsafe` code\n- NEVER break existing functionality\n- NEVER make semantic changes\n- Only optimize files that were actually changed\n- Preserve all existing comments and documentation\n\n## SAFETY RULES\n- If unsure about an optimization, defer it\n- Prioritize code clarity over micro-optimizations\n- Test after every change\n- Document reasoning for deferred optimizations"
  }
}