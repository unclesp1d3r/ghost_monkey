{
    "enabled": true,
    "name": "Rust Code Quality Analyzer",
    "description": "Monitors Rust source files and protobuf definitions for changes, then analyzes and improves code quality across 8 focus categories while preserving public APIs. Automatically applies safe edits and provides detailed improvement reports.",
    "version": "1",
    "when": {
        "type": "fileEdited",
        "patterns": [
            "**/*.rs",
            "**/*.proto",
            "**/Cargo.toml",
            "**/build.rs"
        ]
    },
    "then": {
        "type": "askAgent",
        "prompt": "# Rust Code Quality Analysis & Improvement\n\nAnalyze ONLY the changed files in the current diff for code quality issues and apply safe improvements.\n\n## EXECUTION STEPS\n1. **Identify Changed Files**: List all modified .rs, .proto, Cargo.toml, build.rs files in current diff\n2. **Quality Analysis**: Analyze each changed file against the 8 focus categories below\n3. **Apply Safe Edits**: Make only mechanical, non-breaking quality improvements\n4. **Validate**: Run `just lint && just test` to ensure changes don't break anything\n5. **Report**: Provide summary of applied changes and deferred items\n\n## CODE QUALITY CATEGORIES\n\n### 1. Code Smells\n- ✅ Remove dead/unreachable code\n- ✅ Split oversized internal functions (keep public APIs unchanged)\n- ✅ Eliminate duplicate code blocks\n- ❌ Flag complex functions for review\n\n### 2. Design Patterns\n- ✅ Add private helper traits for internal use\n- ✅ Introduce builder patterns for complex constructors (internal)\n- ✅ Apply newtype patterns for type safety (internal)\n- ❌ Flag major architectural changes for review\n\n### 3. Best Practices\n- ✅ Replace blocking I/O with async equivalents in async contexts\n- ✅ Follow Rust 2024 edition conventions\n- ✅ Apply project-specific conventions\n- ✅ Fix clippy warnings and suggestions\n\n### 4. Readability\n- ✅ Improve variable/function naming (internal only)\n- ✅ Add rustdoc comments to public APIs\n- ✅ Improve code structure and organization\n- ✅ Add code examples to documentation\n\n### 5. Maintainability\n- ✅ Extract internal modules (preserve re-exports)\n- ✅ Improve code clarity and documentation\n- ✅ Add missing error context\n- ❌ Flag major refactoring needs for review\n\n### 6. Performance\n- ✅ Eliminate unnecessary `.clone()` calls\n- ✅ Add bounds to Vec growth patterns\n- ✅ Replace blocking operations in async code\n- ✅ Optimize memory allocations\n\n### 7. Type Safety\n- ✅ Replace string-based flags with private enums\n- ✅ Strengthen type constraints\n- ✅ Reduce unnecessary Option/Result nesting\n- ✅ Add type aliases for clarity\n\n### 8. Error Handling\n- ✅ Add context with `.with_context()`\n- ✅ Convert generic errors to structured types (internal)\n- ✅ Ensure no silent failures\n- ✅ Use thiserror for library errors, anyhow for applications\n\n## SAFE EDITS TO APPLY AUTOMATICALLY\n\n```rust\n// ✅ Remove dead code\n#[allow(dead_code)]\nfn unused_function() {} // Remove entirely\n\n// ✅ Add error context\n.map_err(|e| format!(\"Error: {}\", e))\n// becomes:\n.with_context(|| \"Failed to process configuration\")\n\n// ✅ Replace blocking I/O in async\nstd::fs::read_to_string(path)\n// becomes:\ntokio::fs::read_to_string(path).await\n\n// ✅ Eliminate unnecessary clones\nlet name = item.name.clone();\nprocess_string(name);\n// becomes:\nprocess_string(&item.name);\n\n// ✅ Add rustdoc to public APIs\npub fn process_data(data: &str) -> Result<String> {\n// becomes:\n/// Processes the input data and returns a formatted result.\n/// \n/// # Examples\n/// ```\n/// let result = process_data(\"input\")?;\n/// ```\npub fn process_data(data: &str) -> Result<String> {\n```\n\n## CONSTRAINTS\n- **Scope**: Only modify files that appear in the current diff\n- **Safety**: All changes must pass `just lint && just test`\n- **API Stability**: No changes to public function signatures or visibility\n- **Performance**: Avoid changes that add significant overhead\n- **Behavior**: Preserve all existing functionality\n\n## OUTPUT FORMAT\n\n```\n## Code Quality Analysis Summary\n**Files Analyzed**: [list of changed files]\n**Safe Edits Applied**: [count]\n**Items Deferred**: [count]\n**Approval Required**: [count]\n\n### Applied Changes\n- [file]: [description of change and rationale]\n- [file]: [description of change and rationale]\n\n### Deferred Items\n- [file]: [reason for deferral]\n\n### Requires Approval\n- [file]: [quality concern requiring human review]\n\n### Quality Assessment\n[Overall code quality assessment]\n\n### Next Steps\n[Recommended follow-up actions]\n```\n\n## VALIDATION COMMANDS\n```bash\njust lint    # Must pass with zero warnings\njust test    # All tests must pass\n```\n\nIf any validation fails, revert the problematic changes and note in the deferred section.\n\n## PROJECT CONTEXT\nDaemonEye is a security-first process monitoring system with:\n- Zero-warnings policy\n- No unsafe code\n- Async I/O throughout\n- CLI-first design\n- Memory efficiency focus\n- Privilege separation architecture\n\nPrioritize clarity and security over cleverness."
    }
}
